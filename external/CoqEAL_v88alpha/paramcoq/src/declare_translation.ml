(**************************************************************************)
(*                                                                        *)
(*     CoqParam                                                           *)
(*     Copyright (C) 2012                                                 *)
(*                                                                        *)
(*     Chantal Keller                                                     *)
(*     Marc Lasson                                                        *)
(*                                                                        *)
(*     INRIA - École Polytechnique - ÉNS de Lyon                          *)
(*                                                                        *)
(*   This file is distributed under the terms of the GNU Lesser General   *)
(*   Public License                                                       *)
(*                                                                        *)
(**************************************************************************)

open Debug
open Parametricity
open Vars
open Term
open Constr
open Libnames
open Sigma.Notations

let ongoing_translation = Summary.ref false ~name:"parametricity ongoing translation"
let ongoing_translation_opacity = Summary.ref false ~name:"parametricity ongoing translation opacity"
let check_nothing_ongoing () =
  if !ongoing_translation then
    error (Pp.str "Some terms are being translated, please prove pending obligations before starting a new one. End them with the command 'Parametricity Done'.")

let obligation_message () =
  let open Pp in
  Feedback.msg_notice (str "The parametricity tactic generated generated proof obligations. "
          ++  str "Please prove them and end your proof with 'Parametricity Done'. ")

let default_continuation = ignore

let parametricity_close_proof () =
  let proof_obj, terminator = Proof_global.close_proof ~keep_body_ucst_separate:false (fun x -> x) in
  let opacity = if !ongoing_translation_opacity then Vernacexpr.Opaque None else  Vernacexpr.Transparent in
  Pfedit.delete_current_proof ();
  ongoing_translation := false;
  Proof_global.apply_terminator terminator (Proof_global.Proved (opacity,None,proof_obj))

let add_definition ~opaque ~hook ~kind ~tactic name env
                   (evd : 'r Sigma.t) (term : constr run_) typ =
  let Sigma (term_evd, _, _) = term.run evd in
  debug Debug.all "add_definition, term = " env (Sigma.to_evar_map evd) term_evd;
  debug Debug.all "add_definition, typ  = " env (Sigma.to_evar_map evd) typ;
  debug_evar_map Debug.all "add_definition, evd  = " (Sigma.to_evar_map evd);
  let init_tac =
    let open Proofview in
    let unsafe = true in
    tclTHEN (Refine.refine ~unsafe term) tactic
  in
  let open Proof_global in
  let open Vernacexpr in
  ongoing_translation_opacity := opaque;
  Lemmas.start_proof name ~init_tac kind (Sigma.to_evar_map evd) typ hook;
  let proof = Proof_global.give_me_the_proof () in
  let is_done = Proof.is_done proof in
  if is_done then
    parametricity_close_proof ()
  else begin
    ongoing_translation := true;
    obligation_message ()
  end

let declare_abstraction ?(opaque = false) ?(continuation = default_continuation)
                        ?kind arity env a name evd =
  Debug.debug_evar_map Debug.all "declare_abstraction, evd  = " (Sigma.to_evar_map evd);
  let program_mode_before = Flags.is_program_mode () in
  Obligations.set_program_mode !Parametricity.program_mode;
  debug [`Abstraction] "declare_abstraction, a =" env (Sigma.to_evar_map evd) a;
  let b = Retyping.get_type_of env (Sigma.to_evar_map evd) a in
  debug [`Abstraction] "declare_abstraction, b =" env (Sigma.to_evar_map evd) b;
  let b = Retyping.get_type_of env (Sigma.to_evar_map evd) a in
  let Sigma (b_R, evd, p1) = relation arity env b evd in
  let sub = range (fun k -> prime arity k a) arity in
  let b_R = substl sub b_R in
  let a_R = {run = fun evd -> translate arity env a evd}
  in
  let hook =
    match kind_of_term a with
      | Const cte when
          (try ignore (Relations.get_constant arity (Univ.out_punivs cte)); false with Not_found -> true)
        ->
         (Lemmas.mk_hook (fun _ dcl ->
           if !ongoing_translation then error (Pp.str "Please use the 'Debug.Done' command to end proof obligations generated by the parametricity tactic.");
           Pp.(Flags.if_verbose Feedback.msg_info (str (Printf.sprintf "'%s' is now a registered translation." (Names.Id.to_string name))));
            Relations.declare_relation arity (Globnames.ConstRef (Univ.out_punivs cte)) dcl;
            continuation ()))
      | _ -> (Lemmas.mk_hook (fun _ dcl -> continuation ()))
  in
  let kind = match kind with
                 None -> Decl_kinds.Global, true, Decl_kinds.DefinitionBody Decl_kinds.Definition
           | Some kind -> kind in
  let tactic = snd (Relations.get_parametricity_tactic ()) in
  add_definition ~tactic ~opaque ~kind ~hook name env evd a_R b_R;
  Obligations.set_program_mode program_mode_before


let declare_inductive name ?(continuation = default_continuation) arity evd env (((mut_ind, _) as ind, inst)) =
  let mut_body, _ = Inductive.lookup_mind_specif env ind in
  debug_string [`Inductive] "Translating mind body ...";
  let Sigma (translation_entry, evd, p1) =
    Parametricity.translate_mind_body name arity env mut_ind mut_body inst evd in
  debug_string [`Inductive] ("Translating mind body ... done.");
  debug_evar_map [`Inductive] "evar_map inductive " (Sigma.to_evar_map evd);
  let size = Declarations.(Array.length mut_body.mind_packets) in
  let mut_ind_R = Command.declare_mutual_inductive_with_eliminations translation_entry [] in
  for k = 0 to size-1 do
    Relations.declare_inductive_relation arity (mut_ind, k) (mut_ind_R [], k)
  done;
  continuation ()

let translate_inductive_command arity c name =
  let (evd, env) = Lemmas.get_current_context () in
  let (evd, c) = Constrintern.interp_open_constr env evd c in
  let (ind, _) as pind, _ =
    try
      Inductive.find_rectype env c
    with Not_found ->
      error (Pp.(str "Unable to locate an inductive in " ++ Printer.pr_constr_env env evd c))
  in
  try
    let ind_R = Globnames.destIndRef (Relations.get_inductive arity ind) in
    error (Pp.(str "The inductive " ++ Printer.pr_inductive env ind ++ str " already as the following registered translation " ++ Printer.pr_inductive env ind_R))
  with Not_found ->
  let evd = Sigma.Unsafe.of_evar_map evd in
  declare_inductive name arity evd env pind

let declare_realizer ?(continuation = default_continuation) ?kind
  ?(real : Constr.t Sigma.run option) arity env name (var : constr)
  (evd : 'r Sigma.t) =
  let gref = Term.(match kind_of_term var with
     | Var id -> Globnames.VarRef id
     | Const (cst, _) -> Globnames.ConstRef cst
     (* | Ind (ind, _) -> Globnames.IndRef ind *)
     (* | Constructor (cstr, _) -> Globnames.ConstructRef cstr *)
     | _ -> error (Pp.str "Realizer works only for variables and constants.")) in
  let Sigma (typ, evd, p1) = Parametricity.unsafe_e_
              (fun evdr -> Typing.e_type_of env evdr var) evd in
  let Sigma (typ_R, evd, p2) = Parametricity.relation arity env typ evd in
  let sub = range (fun _ -> var) arity in
  let typ_R = Vars.substl sub typ_R in
  let cpt = ref 0 in
  let real = {run = fun evd ->
    incr cpt;
    match real with
      Some real ->
      let Sigma (term, evd, p1) = real.run evd  in
      let realtyp = Retyping.get_type_of env (Sigma.to_evar_map evd) term in
      debug [`Realizer] (Printf.sprintf "real in realdef (%d) =" !cpt) env (Sigma.to_evar_map evd) term;
      debug [`Realizer] (Printf.sprintf "realtyp in realdef (%d) =" !cpt) env (Sigma.to_evar_map evd) realtyp;
      let Sigma (_, evd, p2) = Parametricity.unsafe_e_ (fun evdr ->
         Evarconv.e_cumul env evdr realtyp typ_R) evd in
      let Sigma ((nf, _), evd, p3) = Parametricity.unsafe_e_ (fun evdr ->
                      Evarutil.e_nf_evars_and_universes evdr) evd in
      let term = nf term in
      debug [`Realizer] (Printf.sprintf "real in realdef (%d), after =" !cpt) env (Sigma.to_evar_map evd) term;
      debug [`Realizer] (Printf.sprintf "realtyp in realdef (%d), after =" !cpt) env (Sigma.to_evar_map evd) realtyp;
      Sigma (term, evd, p1 +> p2 +> p3)
    | None -> Evarutil.new_evar env evd typ_R}
  in
  let kind = Decl_kinds.Global, true, Decl_kinds.DefinitionBody Decl_kinds.Definition in
  let name = match name with Some x -> x | _ ->
     let name_str =  Term.(match kind_of_term var with
     | Var id -> Names.Id.to_string id
     | Const (cst, _) -> Names.Label.to_string (Names.Constant.label cst)
     | _ -> assert false)
     in
     let name_R = translate_string arity name_str in
     Names.Id.of_string name_R
  in
  debug_evar_map [`Realizer] "ear_map =" (Sigma.to_evar_map evd);
  let hook = Lemmas.mk_hook (fun _ dcl ->
    Pp.(Feedback.msg_info (str (Printf.sprintf "'%s' is now a registered translation." (Names.Id.to_string name))));
    Relations.declare_relation arity gref dcl;
    continuation ()) in
  let tactic = snd (Relations.get_parametricity_tactic ()) in
  add_definition ~tactic  ~opaque:false ~kind ~hook name env evd real typ_R

let realizer_command arity name var real =
  let (evd, env) = Lemmas.get_current_context () in
  let (evd, var) = Constrintern.interp_open_constr env evd var in
  Obligations.check_evars env evd;
  let evd = Sigma.Unsafe.of_evar_map evd in
  let real = {run = fun evd ->
     Parametricity.unsafe_swap_ (fun evd ->
         Constrintern.interp_open_constr env evd real) evd} in
  declare_realizer arity env name var ~real evd

let rec list_continuation final f l _ = match l with [] -> final ()
   | hd::tl -> f (list_continuation final f tl) hd

let rec translate_module_command ?name arity r  =
  check_nothing_ongoing ();
  let (loc, qid) = qualid_of_reference r in
  try
    let globdir = Nametab.locate_dir qid in
    match globdir with
    | DirModule (_, (mp, _)) ->
       let mb = Global.lookup_module mp in
       declare_module ?name arity mb
    | _ -> assert false
  with Not_found -> error Pp.(str "Unknown Module " ++ pr_qualid qid)

and id_of_module_path mp =
 let open Names in
 let open ModPath in
 match mp with
   | MPdot (_, lab) -> Label.to_id lab
   | MPfile dp -> List.hd (DirPath.repr dp)
   | MPbound id -> MBId.to_id id

and declare_module ?(continuation = ignore) ?name arity mb  =
  debug_string [`Module] "--> declare_module";
  let open Declarations in
  let mp = mb.mod_mp in
  match mb.mod_expr, mb.mod_type with
  | Algebraic _, NoFunctor fields
  | FullStruct, NoFunctor fields ->
     let id = id_of_module_path mp in
     let id_R = match name with Some id -> id | None -> translate_id arity id in
     debug_string [`Module] (Printf.sprintf "start module: '%s' (translating '%s')."
       (Names.Id.to_string id_R) (Names.Id.to_string id));
     let mp_R = Global.start_module id_R in
     (* I have no idea what I'm doing here : *)
     let fs = Summary.freeze_summaries ~marshallable:`No in
     let _ = Lib.start_module None id_R mp_R fs in
     list_continuation
     (fun _ ->
       debug_string [`Module] (Printf.sprintf "end module: '%s'." (Names.Id.to_string id_R));
       ignore (Declaremods.end_module ()); continuation ())
     (fun continuation -> function
     | (lab, SFBconst cb) when (match cb.const_body with OpaqueDef _ -> false | Undef _ -> true | _ -> false) ->
       let (evd, env) = Evd.empty, Global.env () in
       let cst = Mod_subst.constant_of_delta_kn mb.mod_delta (Names.KerName.make2 mp lab) in
       if try ignore (Relations.get_constant arity cst); true with Not_found -> false then
         continuation ()
       else
       debug_string [`Module] (Printf.sprintf "axiom field: '%s'." (Names.Label.to_string lab));
       let evd = Sigma.Unsafe.of_evar_map evd in
       declare_realizer ~continuation arity env None (mkConst cst) evd

     | (lab, SFBconst cb) ->
       let opaque =
         match cb.const_body with OpaqueDef _ -> true | _ -> false
       in
       let kind = Decl_kinds.(Global, cb.const_polymorphic, DefinitionBody Definition) in
       let (evd, env) = Evd.empty, Global.env () in
       let cst = Mod_subst.constant_of_delta_kn mb.mod_delta (Names.KerName.make2 mp lab) in
       if try ignore (Relations.get_constant arity cst); true with Not_found -> false then
         continuation ()
       else
       let evd, ucst =
          Evd.(with_context_set univ_rigid evd (Universes.fresh_constant_instance env cst))
       in
       let c = mkConstU ucst in
       let lab_R = translate_id arity (Names.Label.to_id lab) in
       debug [`Module] "field : " env evd c;
       (try
        let evd, typ = Typing.type_of env evd c in
        debug [`Module] "type :" env evd typ
       with e -> error (Pp.str  (Printexc.to_string e)));
       debug_string [`Module] (Printf.sprintf "constant field: '%s'." (Names.Label.to_string lab));
       let evd = Sigma.Unsafe.of_evar_map evd in
       declare_abstraction ~opaque ~continuation ~kind arity env c lab_R evd

     | (lab, SFBmind _) ->
       let (evd, env) = Evd.empty, Global.env () in
       let mut_ind = Mod_subst.mind_of_delta_kn mb.mod_delta (Names.KerName.make2 mp lab) in
       let ind = (mut_ind, 0) in
       if try ignore (Relations.get_inductive arity ind); true with Not_found -> false then
         continuation ()
       else begin
         let evd, pind =
            Evd.(with_context_set univ_rigid evd (Universes.fresh_inductive_instance env ind))
         in
         debug_string [`Module] (Printf.sprintf "inductive field: '%s'." (Names.Label.to_string lab));
	 let ind_name = Names.id_of_string
          @@ translate_string arity
          @@ Names.Label.to_string
          @@ Names.MutInd.label
          @@ mut_ind
	 in
         let evd = Sigma.Unsafe.of_evar_map evd in
         declare_inductive ind_name ~continuation arity evd env pind
       end
     | (lab, SFBmodule mb') when
          match mb'.mod_type with NoFunctor _ ->
            (match mb'.mod_expr with FullStruct | Algebraic _ -> true | _ -> false)
          | _ -> false
        -> declare_module ~continuation arity mb'

     | (lab, _) ->
         Pp.(Flags.if_verbose Feedback.msg_info (str (Printf.sprintf "Ignoring field '%s'." (Names.Label.to_string lab))));
          continuation ()
     ) fields ()
  | Struct _, _ -> error Pp.(str "Module " ++ (str (Names.ModPath.to_string mp))
                                 ++ str " is an interactive module.")
  | Abstract, _ -> error Pp.(str "Module " ++ (str (Names.ModPath.to_string mp))
                                 ++ str " is an abstract module.")
  | _ -> Feedback.msg_warning Pp.(str "Module " ++ (str (Names.ModPath.to_string mp))
                                 ++ str " is not a fully-instantiated module.");
         continuation ()


let command_variable ?(continuation = default_continuation) arity variable names =
  error (Pp.str "Cannot translate an axiom nor a variable. Please use the 'Parametricity Realizer' command.")

let command_constant ?(continuation = default_continuation) arity constant names =
  let poly, opaque =
    let cb = Global.lookup_constant constant in
    Declarations.(cb.const_polymorphic, match cb.const_body with Def _ -> false | _ -> true)
  in
  let name = match names with
      | None ->
             Names.id_of_string
          @@ translate_string arity
          @@ Names.Label.to_string
          @@ Names.Constant.label
          @@ constant
      | Some name -> name
  in
  let kind = Decl_kinds.(Global, poly, DefinitionBody Definition) in
  let (evd, env) = Lemmas.get_current_context () in
  let evd, pconst =
    Evd.(with_context_set univ_rigid evd (Universes.fresh_constant_instance env constant))
  in
  let constr = mkConstU pconst in
  let evd = Sigma.Unsafe.of_evar_map evd in
  declare_abstraction ~continuation ~opaque ~kind arity env constr name evd

let command_inductive ?(continuation = default_continuation) arity inductive names =
  let (evd, env) = Lemmas.get_current_context () in
  let evd, pind =
    Evd.(with_context_set univ_rigid evd (Universes.fresh_inductive_instance env inductive))
  in
  let name = match names with
      | None ->
             Names.id_of_string
          @@ translate_string arity
          @@ Names.Label.to_string
          @@ Names.MutInd.label
          @@ fst
	  @@ fst
	  @@ pind
      | Some name -> name
  in
  let evd = Sigma.Unsafe.of_evar_map evd in
  declare_inductive name ~continuation arity evd env pind


let command_constructor ?(continuation = default_continuation) arity gref names =
  let open Pp in
  error ((str "'")
        ++ (Printer.pr_global gref)
        ++ (str "' is a constructor. To generate its parametric translation, please translate its inductive first."))

let command_reference ?(continuation = default_continuation) arity gref names =
   check_nothing_ongoing ();
   let open Globnames in
   match gref with
   | VarRef variable ->
     command_variable ~continuation arity variable names
   | ConstRef constant ->
     command_constant ~continuation arity constant names
   | IndRef inductive ->
     command_inductive ~continuation arity inductive names
   | ConstructRef constructor ->
     command_constructor ~continuation arity gref names

let command_reference_recursive ?(continuation = default_continuation) arity gref =
  let open Globnames in
  let label = Names.Label.of_id (Nametab.basename_of_global gref) in
  let c = printable_constr_of_global gref in
  let (direct, graph, _) = Assumptions.traverse label c in
  let inductive_of_constructor ref =
    let open Globnames in
    if not (isConstructRef ref) then ref else
     let (ind, _) = Globnames.destConstructRef ref in
     Globnames.IndRef ind
  in
  let rec fold_sort graph visited nexts f acc =
    Refset_env.fold (fun ref ((visited, acc) as visacc) ->
          let ref_ind = inductive_of_constructor ref in
          if Refset_env.mem ref_ind visited
          || Relations.is_referenced arity ref_ind  then visacc else
          let nexts = Refmap_env.find ref graph in
          let visited = Refset_env.add ref_ind visited in
          let visited, acc = fold_sort graph visited nexts f acc in
          let acc = f ref_ind acc in
          (visited, acc)
     ) nexts (visited, acc)
  in
  let _, dep_refs = fold_sort graph Refset_env.empty direct (fun x l -> (inductive_of_constructor x)::l) [] in
  let dep_refs = List.rev dep_refs in
  (* DEBUG:
  List.iter (fun x -> let open Pp in msg_info (Printer.pr_global x)) dep_refs; *)
  list_continuation continuation (fun continuation gref -> command_reference ~continuation arity gref None) dep_refs ()

let translate_command arity c name =
  if !ongoing_translation then error (Pp.str "On going translation.");
  let open Constrexpr in
  let (evd, env) = Lemmas.get_current_context () in
  let (evd, c) = Constrintern.interp_open_constr env evd c in
  let cte_option =
    match Term.kind_of_term c with Term.Const cte -> Some cte | _ -> None
  in
  let poly, opaque =
    match cte_option with
    | Some (cte, _) ->
        let cb = Global.lookup_constant cte in
        Declarations.(cb.const_polymorphic,
             match cb.const_body with Def _ -> false
                                        | _ -> true)
    | None -> false, false
  in
  let kind = Decl_kinds.(Global, poly, DefinitionBody Definition) in
  let evd = Sigma.Unsafe.of_evar_map evd in
  declare_abstraction ~opaque ~kind arity env c name evd
